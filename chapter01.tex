%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Обзор и сравнительный анализ существующих подходов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
В данном разделе вводятся основные определения, связанные с предметной областью, приводятся различные классификации. Рассматриваются существующие подходы к обнаружению клонов и приводятся их основные характеристики.

Также в данном разделе приводится сравнительный анализ архитектур нейронных сетей
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Основные определения и классификация}

Для рассмотрения существующих подходов к обнаружению клонов, в первую очередь необходимо дать основные определения и классификации, связанные с предметной областью. 

\begin{itemize}
\setlength\itemsep{0mm}
\item \textbf{Фрагмент кода} - часть исходного кода, необходимая для запуска программы. Такая часть может содержать в себе функцию или метод, блоки или последовательности операторов;
\item \textbf{Клон кода} - скопированный фрагмент кода с различными типами изменений: большими, незначительными или без таковых;
\item \textbf{Клоновый класс} - множество фрагментов кода, в котором любые два фрагмента являются клонами;
\item \textbf{Кандидат в клоны} - пара фрагментов кода, сравниваемая на наличие сходств.
\end{itemize}

С точки зрения идентичности дублированных фрагментов, клоны делятся на следующие типы:
\begin{itemize}
\setlength\itemsep{0mm}
\item I: Полностью идентичные фрагменты программы c точностью до разметки и комментариев~\cite{akhinitsykson, surveyroyandcordy}.
\item II: Клоны, идентичные клонам первого типа, в которых также не учитваются различия идентификаторов, типов и литералов~\cite{akhinitsykson, surveyroyandcordy}.
\item III: Синтаксически схожие фрагменты, различающиеся на уровне операторов, т.е. операторы могут быть добавлены, изменены или удалены в добавление к изменениям, учитываемым во втором типе~\cite{akhinitsykson, surveyroyandcordy}.
\item VI: Фрагменты программы, решающие схожую задачу, но реализованные различными способами (семантические клоны)~\cite{akhinitsykson, surveyroyandcordy}.
\end{itemize}

При рассмотрении клонов с точки зрения их размера, выделяют следующие виды:
\begin{itemize}
\setlength\itemsep{0mm}
\item С фиксированной гранулярностью: идентичные фрагменты кода фиксированного размера (методы классы и т.д.).
\item С производной гранулярностью: идентичные фрагменты произвольного размера
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Причины возникновения}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Клоны в коде не появляются сами по себе. Существует несколько причин, которые могут подтолкнуть разработчиков ко внедрению клонов в систему. Далее приведены некоторые причины их появления.

\subsection{Стратегия разработки}

Клоны в программных системах могут появляться из-за повторного использования или programming approach. Например:

\subsubsection{Повторное использование}

Повторное использование кода, логики, дизайна и/или всей системы являются основными причинами возникновения дубликатов кода.

\textbf{Повторное использование за счет копирования/вставки}. Повторное использование кода посредством копирования/вставки (с незначительными изменениями или без них) самый простой и распространенный вид механизма повторного использования в процессе разработки. Такой способ является быстрым способом повторного использования надежных синтаксических и семантических конструкций~\cite{copypaste}.

\textbf{Ответвление}. Термин ответвление был использован Каспером и Годфри~\cite{forking} для того, чтобы обозначить повторное использование подобных решений с их возможным расхождением. Например, при разработке драйвера для семейства аппаратных устройств, похожее семейство устройств может уже иметь драйвер. Таким образом, этот драйвер может быть использован с незначительными изменениями. Аналогично, клоны могут появляться при переносе ПО с одной платформы на другую. 

\subsubsection{Подход к программированию}

Клоны, также могут появляться во время разработки ПО. Например:

\textbf{Слияние двух похожих систем}. Иногда две программные системы с похожей функциональностью объединяются с целью создания новой. Также, такие системы могут быть разработаны разными командами, и, тогда, клоны при объединении появляются из-за реализации похожих функциональностей в обеих системах.

\textbf{Разработка системы с помощью генеративного подхода}. Генерация кода может породить огромное количество клонов из-за использования одинаковых шаблонов для генерации одинаковой или похожей логики.

\subsection{Преимущества поддержки ПО}

Еще одна из причин появления клонов - получение некоторых выгод обслуживания.

\textbf{Чистая и понятная архитектура ПО}. Иногда клоны намеренно внедряются в ПО для поддержания чистой и понятной архитектуры~\cite{forking}.

\textbf{Высокая стоимость вызовов функций}. В программах реального времени вызовы функций могут быть слишком затратными. В том случае, когда компилятор не предлагает встроить код автоматически, это приходится делать вручную, что непременно влечет за собой появление клонов.

\subsection{Преодоление ограничений}

Клоны могут появиться из-за различных ограничений в языках программирования.

\subsubsection{Ограничения языка}

\textbf{Значительные усилия при написании повторноиспользуемого кода}. Написание кода который потом можно будет повторно использовать слишком трудо- и времязатратно. Поэтому, в неоторых случаях, проще создать клон, чем тратить силы на написание общего кода.

\textbf{Отсутствие механизма повторного использования в языке программирования}. Иногда, в языках программирования не хватает механизмов абстракции, например наследования, общих типов или передачи параметров. В следствии этого разработчикам приходится применять их как идиомы. Такие повторяющиеся действия могут создавать возможно небольшие и потенциально часто используемые клоны~\cite{templates, javasys}.

\subsubsection{Ограничения в работе программистов}

\textbf{Сложности в понимании больших систем}. Обычно сложно понять большую программную систему. Такие сложности толкают программистов к использованию пример-ориентированного программирования путем адаптации уже существующего кода.

\textbf{Временные ограничения}. Одними из основных причин появления клонов являются временные рамки доступные разработчикам. В большинстве случаев, разработчикам отведено ограниченное количество времени для завершения проекта или его части. Из-за таких ограничений разработчики ищут легкие пути решения проблем и, следовательно, ищут похожие существующие решения. 

\textbf{Неправильный способ измерения продуктивности}. Иногда, продуктивность разработчиков измеряется в количеством написанных строк кода в час. В таких случаях, программисты фокусируются на увеличении количества строк кода и, следовательно, пытается использовать уже существующий код.

\subsection{Случайное клонирование}

В конечном итоге, клоны могут случайно появляться в ПО.

\textbf{Протоколы взаимодействия с API и библиотеками}. Для использования API обычно требуются серии вызовов функций и/или другие последовательности команд. Например, при создании кнопки с помощью Java SWING API, серии команд включают в себя: создание кнопки, добавление ее в контейнер и назначение обработчиков событий~\cite{fingerprints}.

\section{Преимущества обнаружения клонов}

Помимо очевидного понимания возможностей улучшения качества кода с помощью рефакторинга клонов, есть и другие преимущества поиска клонов в коде. Например: 

\textbf{Выявление потенциальных библиотечных методов}. В своих работах Дэвей~\cite{davey}, Берд и Мунро~\cite{burdmunro} отметили, что многочисленное использование скопированного кода доказывает его удобство использования. Такой код может быть включен в библиотеку и беспрепятственно повторно использоваться в дальнейшем.

\textbf{Помощь в понимании программы}. В том случае, когда функциональность программы осмысленна, возможно создать полную картину о других файлах, содержащих похожие копии этого фрагмента. Например, если фрагмент кода отвечает за управление памятью, можно сделать вывод, что все файлы, содержащие копию, должны иметь реализацию структуры с динамическим распределением память~\cite{memex}.

\textbf{Поиск шаблонов}. В том случае, когда все дублированные фрагменты одного исходного участка могут быть найдены, может быть обнаружена функциональная схема использования этого фрагмента~\cite{memex}.

\textbf{Поиск плагиата и нарушения авторских прав}. Поиск схожего кода может быть полезным в поиске плагиата и нарушения авторских прав~\cite{plagiat}.

\textbf{Уменьшение размера кода}. Методы поиска клонов позволяют сделать исходный код более компактным.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Критерии сравнения}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

При анализе подходов к обнаружению дублированных участков необходимо выделить основные характеристики для их сравнения. Ключевыми характеристиками метода можно считать:
\begin{itemize}
\setlength\itemsep{0mm}
\item типы обнаруживаемых клонов
\item полнота получаемых результатов
\item точность получаемых результатов
\end{itemize}

В таком случае, основное требование к подходу - обнаружение клонов первых трех типов.

При сравнении архитектур нейронных сетей, необходимо принимать во внимание область применения таких сетей и их эффективность в этой области.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Способы обнаружения клонов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Как правило, процесс обнаружения клонов состоит из двух этапов: трансформации и сравнения. На первом этапе код преобразуется в промежуточное внутреннее представление, которое позволяет использовать более эффективные и специализированные алгоритмы сравнения. В то же время, выбор промежуточного представления накладывает ограничения на используемые алгоритмы и во многом определяет качество итоговых результатов.

Методы поиска клонов могут быть классифицированы в зависимости от способа внутреннего представления кода:
\begin{itemize}
\setlength\itemsep{0mm}
\item на основе анализа текста
\item на основе анализа токенов
\item на основе анализа синтаксических деревьев
\item на основе анализа графов
\item на основе программных метрик
\item смешанные методы
\end{itemize}

\subsection{Метод на основе анализа текста}

Подходы такого типа производят малое (или не производят вообще) количество изменений или нормализаций перед фактическим сравнением. В большинстве случаев используется непосредственно сам исходный код программы, представленный в виде последовательности строк. В полученной последовательности производится поиск одинаковых фрагментов наибольшей длины. Поиск таких фрагментов осуществляется при помощи методов анализа данных или строковых алгоритмов. К таким относятся методы сравнения отпечатков строк~\cite{fingerprints}, поиска по шаблону~\cite{templates2}, нахождения частой последовательности~\cite{sequence} и т.д.

Однако, высокая чувствительность к изменениям в исходной программе является главным недостатком подходов такого типа. Без применения модификаций такое представление позволяет обнаруживать только клоны первого типа. Для обнаружения клонов второго типа необходимо применять различного рода модификации: литералы и идентификаторы заменяются на специальные константы. Благодаря описанным модификациям, при обнаружении схожих фрагментов, такие различия не учитываются.

\subsection{Метод на основе анализа токенов}

В данном семействе подходов исходный код обрабатывается и представляется в виде последовательности, так называемых, токенов (уникальных последовательностей символов). Следующим этапом применяются строковые алгоритмы для поиска дубликатов в последовательности токенов. В отличии от методов на основе анализа текстов, такие методы позволяют использовать более эффективные и устойчивые к изменениям программы методы. Эффективность таких методов достигается за счет более компактного внутреннего представления, а их устойчивость - за счет фильтрации и нормализации токенов.

\subsection{Метод на основе анализа синтаксических деревьев}

В рамках данного подхода исходный код программы представляется в виде дерева разбора или абстрактного синтаксического дерева (AST). Такой подход использует структурную информацию о программе, что позволяет обнаруживать клоны первых трех типов. Однако, семантика программы не учитывается, что приводит к невозможности обнаружения клонов четвертого типа, а также клонов с измененным порядком операторов.

Для обнаружения дублированных фрагментов кода с помощью анализа деревьев, используются алгоритмы поиска одинаковых поддеревьев. Такие методы, как правило, базируются на алгоритмах динамического программирования~\cite{dynamicprog}, либо пытаются свести задачу к поиску одинаковых подстрок~\cite{substrings}. Еще один подход, относящийся к рассматриваемому семейству методов - дополнение узлов дерева метриками, которые характеризуют соответствующие поддеревья~\cite{subtrees}. Такой прием сильно упрощает задачу, позволяя найти ее решение за время, пропорциональное длине исходного кода.

При конвертации AST в XML (eXtensible Markup Language) и использовании технологий глубинного анализа данных, появляется возможность нахождения точные и параметризованные клоны на более абстрактном уровне. Во избежании сложностей, связанных с полным сравнением AST, поддеревья представляются в виде сериализованных последовательностей токенов (суффиксного дерева), что позволяет более эффективно находить синтаксические клоны.

\nomenclature{AST}{Abstract Syntax Tree}
\nomenclature{XML}{eXtensible Markup Language}

\subsection{Метод на основе анализа графов}

Методы, основанные на анализе графов углубляются в абстракцию исходного кода за счет учета семантической информации, заключенной в графах зависимостей, захватывающих информацию управления и потока данных. Для поиска схожих подграфов используется алгоритм изоморфизма для подграфов, применяемый на графе программных зависимостей (PDG). Один из ведущих способов поиска клонов, основанного на данном семействе методов, - поиск изоморфных подграфов PDG с помощью (обратного) разбиения программы на элементы~\cite{PDGdetect}. 

\nomenclature{PDG}{Program Dependency Graph}

\subsection{Метод на основе программных метрик}

Еще одно семейство методов основано на сборе различных метрик, связанных с фиксированными фрагментами кода. Такой подход позволяет после сбора метрик сравнить их между собой, вместо сравнения исходного кода напрямую. В различных предложенных методах использовались различные программные метрики для поиска клонов. Например, в качестве метрики можно принимать количество строк исходного кода (LOCs), количество вызовов функций, количество ребер графа потока управления (CFG). Такие метрики рассчитываются для каждого функционального элемента программы. Те элементы у которых схожие метрики считаются клонами. Рассматриваемый подход позволяет отыскать клоны на уровне функций, но не справляется с поиском клонов меньших размеров~\cite{2018art}

\nomenclature{LOC}{Lines of Code}
\nomenclature{CFG}{Control Flow Graph}

\subsection{Смешанные методы}

Помимо рассмотренных методов, существует такая группа, которая использует смешанный подход. Иными словами, используются несколько из рассмотренных выше структур для создания внутреннего представления программы. Одним из самых популярных гибридных подходов является получение и сериализация синтаксического дерева в последовательность токенов~\cite{hybrid}. Такое смешивание позволяет анализировать структурную информацию, получаемую из AST, используя эффективные строковые алгоритмы. 

\section{Искусственные нейронные сети}

На текущий момент искусственные нейронные сети (НС) достигли высокой производительности в таких задачах поиска схожих элементов, как, например, поиск одинаковых изображений, фотографий и текста. Данное достижение - одна из основных причин, по которой было решено использовать искусственные нейронные сети.

\nomenclature{НС}{Нейронная сеть}

Для того, чтобы определить, какая из архитектур НС больше всего подходит для решения поставленной задачи, необходимо провести сравнительный анализ. 

\subsection{Сеть прямого распространения}

Как следует из названия, такая сеть передает информацию только в одном направлении, от входа к выходу. НС состоят из полносвязных слоев (каждый нейрон из одного слоя связан с каждым нейроном следующего слоя), однако, сам слой между собой никак не связан. Каждый слой состоит из входных, скрытых или выходных ячеек~\cite{perceptron}. 

Круг применения таких сетей весьма узок, их можно применять, например, для простых задач классификации или предсказаний. 

\subsection{Нейронная сеть Хопфилда}

Рассматриваемая сеть является полносвязной НС с симметричной матрицей связей. Каждый узел, в такой сети, является входным до начала процесса обучения, скрытым - во время и выходным после обучения. Обучение сети производится с помощью установления желаемого значения нейрона, после чего могут быть рассчитаны веса~\cite{hopfield}. 

Как только веса заданы, обученная сеть становится способной ''распознавать'' входные сигналы - то есть, определять, к какому из запомненных образцов они относятся.

\subsection{Сверточная нейронная сеть}

Сверточная НС отличается от остальных. Основной ее задачей является обработка изображений. Довольно типичной задачей для нее является классификация или обнаружение объектов на изображениях. Как правило, такие сети начинают свою работу с, так называемого, входного ''сканера'', который не пытается анализировать все входные данные разом, а анализирует их небольшими фрагментами, соответствующими его размерам~\cite{cnn}. 

\subsection{Рекуррентная нейронная сеть}

В данном виде НС связи между нейронами образуют своеобразный направленный граф. Благодаря такому строению появляется возможность обработки серии событий во времени или последовательные цепочки. Однако узким местом таких сетей является проблема исчезающего градиента, то есть информация со временем теряется~\cite{rnn}.

\section{Сравнительный анализ}

\subsection{Сравнение методов поиска клонов}

В данной главе были рассмотрены подходы, применяемые в задачах поиска программных клонов, приведены основные определения, связанные с предметной областью. В рамках обзора рассмотрены основные характеристики, преимущества и недостатки методов.

В таблице~\ref{compare} представлен сравнительный анализ подходов на основе следующих характеристик:
\begin{itemize}
\setlength\itemsep{0mm}
\item гранулярность - размер минимального клона
\item тип клонов, которые возможно обнаружить с помощью данного подхода
\item полнота обнаружения
\item точность обнаружения
\end{itemize}

\begin{table}[H]
\centering
\captionsetup{skip=5pt}
\caption{Сравнительный анализ подходов}
\label{compare}
\begin{tabular}{|l|l|l|l|l|}
\hline
Представление    & Гран.		& Тип клонов & Полнота	& Точность \\ \hline
Текст            & Свободная    & I          & Низкая  	& Высокая  \\ \hline
Токены           & Свободная    & I-II       & Высокая 	& Низкая   \\ \hline
Синт. деревья	 & Свободная    & I-III      & Низкая  	& Высокая  \\ \hline
Графы            & Свободная    & I-IV       & Средняя 	& Высокая  \\ \hline
Метрики          & Фикс.		& I-IV       & Средняя 	& Средняя  \\ \hline
\end{tabular}
\end{table}

Учитывая предъявляемые требования, наиболее подходящими методами можно считать методы с внутренним представлением в виде синтаксических деревьев, графов или метрик. В эту же группу добавляются и гибридные методы. Однако, у методов, основанных на представлении кода в виде синтаксических деревьев, полнота обнаружения клонов в коде очень низкая. Следовательно, такой метод в чистом виде не подходит.

\subsection{Нейронные сети}

В предыдущем разделе были приведены основные виды архитектур НС. Рассмотрены области их применения, их положительные и отрицательные стороны. Основываясь всем вышеперечисленном, можно сделать вывод о наиболее подходящей архитектуре НС. Так как основная задача НС в предлагаемом методе - анализирование кода, то наиболее подходящей архитектурой сети будет являться рекуррентная нейронная сеть.
