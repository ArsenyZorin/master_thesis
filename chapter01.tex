%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Обзор и сравнительный анализ существующих подходов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
В данном разделе вводятся основные определения, связанные с предметной областью, приводятся различные классификации. Рассматриваются существующие подходы к обнаружению клонов, приводятся их основные характеристики и приводится сравнительный анализ архитектур нейронных сетей.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Основные определения и классификация}

Для рассмотрения существующих подходов к обнаружению клонов, в первую очередь необходимо дать основные определения и классификации, связанные с предметной областью. 

\begin{itemize}
\setlength\itemsep{0mm}
\item \textbf{Фрагмент кода} - любая последовательность строк в коде (с учетом комментариев или без);
\item \textbf{Клон кода} - участок исходного кода, который может встречаться более чем однажды (с внесенными изменениями или без них), как внутри одной, так и в нескольких программных сущностях;
\item \textbf{Клоновый класс} - множество фрагментов кода, в котором любые два фрагмента являются клонами;
\item \textbf{Кандидат в клоны} - пара фрагментов кода, сравниваемая на наличие сходств.
\end{itemize}

С точки зрения идентичности дублированных фрагментов, клоны делятся на следующие типы:
\begin{itemize}
\setlength\itemsep{0mm}
\item I: Полностью идентичные фрагменты программы c точностью до разметки и комментариев~\cite{akhinitsykson, surveyroyandcordy}.
\item II: Клоны, в которых не учитваются различия идентификаторов, типов и литералов в дополнении к изменениям, учитываемым в первом типе~\cite{akhinitsykson, surveyroyandcordy}.
\item III: Синтаксически схожие фрагменты, различающиеся на уровне операторов, т.е. операторы могут быть добавлены, изменены или удалены в добавление к изменениям, учитываемым во втором типе~\cite{akhinitsykson, surveyroyandcordy}.
\item VI: Фрагменты программы, решающие схожую задачу, но реализованные различными способами (семантические клоны)~\cite{akhinitsykson, surveyroyandcordy}.
\end{itemize}

При рассмотрении клонов с точки зрения их размера, выделяют следующие виды:
\begin{itemize}
\setlength\itemsep{0mm}
\item С фиксированной гранулярностью: идентичные фрагменты кода фиксированного размера (методы классы и т.д.).
\item С произвольной гранулярностью: идентичные фрагменты произвольного размера
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Причины возникновения}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Можно выделить следующие основные причины появления дублированного кода в ПО:
\begin{itemize}
\setlength\itemsep{0mm}
\item Повторное использование кода;
\item Выбранный подход к программированию;
\item Увеличение выгод обслуживания ПО;
\item Попытки преодоления различных ограничений;
\item Случайность.
\end{itemize}

В зависимости от конкретного проекта, роль той или иной причины в появлении программных клонов может изменяться от незначительной до преобладающей~\cite{akhinitsykson}. Подробнее перечисленные причины будут рассмотрены далее.

\subsection{Повторное использование}

Повторное использование кода, логики, дизайна и/или всей системы являются основными причинами возникновения дубликатов кода. Можно выделить два вида повторного использования кода:

\textbf{Повторное использование за счет копирования/вставки}. Повторное использование кода посредством копирования/вставки (с незначительными изменениями или без них) самый простой и распространенный вид механизма повторного использования в процессе разработки. Такой способ является быстрым способом повторного использования надежных синтаксических и семантических конструкций~\cite{copypaste}.

\textbf{Ответвление}. Термин <<ответвление>> был использован Каспером и Годфри~\cite{forking} для того, чтобы обозначить повторное использование подобных решений с их возможным расхождением. Например, при разработке драйвера для семейства аппаратных устройств, похожее семейство устройств может уже иметь драйвер. Таким образом, этот драйвер может быть использован с незначительными изменениями. Аналогично, клоны могут появляться при переносе ПО с одной платформы на другую. 

\subsection{Подход к программированию}

Клоны, также могут появляться из-за используемого подхода. Например:

\textbf{Слияние двух похожих систем}. Иногда две программные системы с похожей функциональностью объединяются с целью создания новой. Также, такие системы могут быть разработаны разными командами, и, тогда, клоны при объединении появляются из-за реализации похожих функциональностей в обеих системах.

\textbf{Разработка системы с помощью генеративного подхода}. Генерация кода может породить огромное количество клонов из-за использования одинаковых шаблонов для генерации одинаковой или похожей логики.

\subsection{Преимущества поддержки ПО}

Еще одна из причин появления клонов - получение некоторых выгод обслуживания, например:

\textbf{Чистая и понятная архитектура ПО}. Иногда клоны намеренно внедряются в ПО для поддержания чистой и понятной архитектуры~\cite{forking}.

\textbf{Высокие временные затраты при вызове функций}. В программах реального времени вызовы функций могут быть слишком затратными. В том случае, когда компилятор не предлагает заменять вызов функции на код автоматически, это приходится делать вручную, что непременно влечет за собой появление клонов.

\subsection{Преодоление ограничений}

Клоны могут появиться из-за различных ограничений в языках программирования.

\subsubsection{Ограничения языка}

\textbf{Значительные усилия при написании повторноиспользуемого кода}. Написание кода который потом можно будет повторно использовать слишком трудо- и времязатратно. Поэтому, в неоторых случаях, проще создать клон, чем тратить силы на написание общего кода.

\textbf{Отсутствие механизма повторного использования в языке программирования}. Иногда, в языках программирования не хватает механизмов абстракции, например наследования, общих типов или передачи параметров. В следствии этого разработчикам приходится применять их как идиомы. Такие повторяющиеся действия могут создавать возможно небольшие и потенциально часто используемые клоны~\cite{templates, javasys}.

\subsubsection{Ограничения в работе программистов}

\textbf{Сложности в понимании больших систем}. Обычно сложно понять большую программную систему. Такие сложности толкают программистов к использованию пример-ориентированного программирования путем адаптации уже существующего кода.

\textbf{Временные ограничения}. Одними из основных причин появления клонов являются временные рамки доступные разработчикам. В большинстве случаев, разработчикам отведено ограниченное количество времени для завершения проекта или его части. Из-за таких ограничений разработчики ищут легкие пути решения проблем и, следовательно, ищут похожие существующие решения. 

\textbf{Неправильный способ измерения продуктивности}. Иногда, продуктивность разработчиков измеряется в количеством написанных строк кода в час. В таких случаях, программисты фокусируются на увеличении количества строк кода и, следовательно, пытается использовать уже существующий код.

\subsection{Случайное клонирование}

В конечном итоге, клоны могут случайно появляться в ПО.

\textbf{Протоколы взаимодействия с API и библиотеками}. Для использования API обычно требуются серии вызовов функций и/или другие последовательности команд. Например, при создании кнопки с помощью Java SWING API, серии команд включают в себя: создание кнопки, добавление ее в контейнер и назначение обработчиков событий~\cite{fingerprints}.

\section{Преимущества обнаружения клонов и их дальнейшего рефакторинга}

Помимо очевидного понимания возможностей улучшения качества кода с помощью рефакторинга клонов, есть и другие преимущества поиска клонов в коде. Например: 

\textbf{Выявление потенциальных библиотечных методов}. В своих работах Дэвей~\cite{davey}, Берд и Мунро~\cite{burdmunro} отметили, что многочисленное использование скопированного кода доказывает его удобство использования. Такой код может быть включен в библиотеку и беспрепятственно повторно использоваться в дальнейшем.

\textbf{Улучшение наглядности программы}. В случае осмысленной функциональности программы, появляется возможность создания полной картины о других файлах, содержащих похожие копии этого фрагмента. Например, если фрагмент кода отвечает за управление памятью, можно сделать вывод, что все файлы, содержащие копию, должны иметь реализацию структуры с динамическим распределением памяти~\cite{memex}.

\textbf{Выделение шаблонов}. В том случае, когда все дублированные фрагменты одного исходного участка могут быть найдены, может быть обнаружена функциональная схема использования этого фрагмента. Иными словами, на основе такого фрагмента и его копий может быть выделен шаблон~\cite{memex}.

\textbf{Поиск плагиата и нарушения авторских прав}. Поиск схожего кода может быть полезным в поиске плагиата и нарушения авторских прав~\cite{plagiat}.

\textbf{Рефакторинг}. Методы поиска клонов позволяют сделать исходный код более компактным.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Критерии сравнения}
\label{section:compare}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

При анализе подходов к обнаружению дублированных участков необходимо выделить основные характеристики для их сравнения. Ключевыми характеристиками метода можно считать:
\begin{itemize}
\setlength\itemsep{0mm}
\item Типы обнаруживаемых клонов;
\item Полнота получаемых результатов;
\item Точность получаемых результатов;
\item Скорость работы.
\end{itemize}

В таком случае, основное требование к подходу - обнаружение клонов первых трех типов.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Способы обнаружения клонов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Как правило, процесс обнаружения клонов состоит из двух этапов: трансформации и сравнения. На первом этапе код преобразуется в промежуточное внутреннее представление, которое позволяет использовать более эффективные и специализированные алгоритмы сравнения. В то же время, выбор промежуточного представления накладывает ограничения на используемые алгоритмы и во многом определяет качество итоговых результатов.

Методы поиска клонов могут быть классифицированы в зависимости от способа внутреннего представления кода:
\begin{itemize}
\setlength\itemsep{0mm}
\item На основе анализа текста;
\item На основе анализа токенов;
\item На основе анализа синтаксических деревьев;
\item На основе анализа графов;
\item На основе программных метрик;
\item Смешанные методы.
\end{itemize}

\subsection{Метод на основе анализа текста}

Подходы такого типа производят малое (или не производят вообще) количество изменений или нормализаций перед фактическим сравнением. В большинстве случаев используется непосредственно сам исходный код программы, представленный в виде последовательности строк. В полученной последовательности производится поиск одинаковых фрагментов наибольшей длины. Поиск таких фрагментов осуществляется при помощи методов анализа данных или строковых алгоритмов. К таким относятся методы сравнения отпечатков строк~\cite{fingerprints}, поиска по шаблону~\cite{templates2}, нахождения частой последовательности~\cite{sequence} и т.д.

Однако, высокая чувствительность к изменениям в исходной программе является главным недостатком подходов такого типа. Без применения модификаций такое представление позволяет обнаруживать только клоны первого типа. Для обнаружения клонов второго типа необходимо применять различного рода модификации: литералы и идентификаторы заменяются на специальные константы. Благодаря описанным модификациям, при обнаружении схожих фрагментов, такие различия не учитываются.

\subsection{Метод на основе анализа токенов}

В данных методах исходный код обрабатывается и представляется в виде последовательности, так называемых токенов (объектов, получаемых в процессе лексического анализа). Следующим этапом применяются строковые алгоритмы для поиска дубликатов в последовательности токенов. В отличии от методов на основе анализа текстов, такие методы позволяют использовать более эффективные и устойчивые к изменениям программы методы. Эффективность таких методов достигается за счет более компактного внутреннего представления, а их устойчивость - за счет фильтрации и нормализации токенов.

\subsection{Метод на основе анализа синтаксических деревьев}

В рамках данного метода исходный код программы представляется в виде дерева разбора или абстрактного синтаксического дерева (Abstract Syntax Tree - AST). Такой подход использует структурную информацию о программе, что позволяет обнаруживать клоны первых трех типов. Однако, семантика программы не учитывается, что приводит к невозможности обнаружения клонов четвертого типа, а также клонов с измененным порядком операторов.

Для обнаружения дублированных фрагментов кода с помощью анализа деревьев, используются алгоритмы поиска одинаковых поддеревьев. Такие методы, как правило, базируются на алгоритмах динамического программирования~\cite{dynamicprog}, либо пытаются свести задачу к поиску одинаковых подстрок~\cite{substrings}. Еще один метод, относящийся к рассматриваемым - дополнение узлов дерева метриками, которые характеризуют соответствующие поддеревья~\cite{subtrees}. Такой прием сильно упрощает задачу, позволяя найти ее решение за время, пропорциональное длине исходного кода.

При конвертации AST в XML (eXtensible Markup Language) и использовании технологий глубинного анализа данных, появляется возможность нахождения точных и параметризованных клонов на более абстрактном уровне. Во избежании сложностей, связанных с полным сравнением AST, поддеревья представляются в виде сериализованных последовательностей токенов (суффиксного дерева), что позволяет более эффективно находить синтаксические клоны.

\nomenclature{AST}{Abstract Syntax Tree}
\nomenclature{XML}{eXtensible Markup Language}

\subsection{Метод на основе анализа графов}

Методы, основанные на анализе графов углубляются в абстракцию исходного кода за счет учета семантической информации, заключенной в графах зависимостей, захватывающих информацию управления и потока данных. Для поиска схожих подграфов используется алгоритм изоморфизма для подграфов, применяемый на графе программных зависимостей (PDG). Один из ведущих способов поиска клонов, основанного на данном семействе методов, - поиск изоморфных подграфов PDG с помощью (обратного) разбиения программы на элементы~\cite{PDGdetect}. 

\nomenclature{PDG}{Program Dependency Graph}

\subsection{Метод на основе программных метрик}

Рассматриваемый метод основан на сборе различных метрик, связанных с фиксированными фрагментами кода. Такой метод позволяет после сбора метрик сравнить их между собой, вместо сравнения исходного кода напрямую. В предложенных методах использовались различные программные метрики для поиска клонов. Например, в качестве метрики можно принимать количество строк исходного кода (LOCs), количество вызовов функций, количество ребер графа потока управления (CFG). Такие метрики рассчитываются для каждого функционального элемента программы. Те элементы у которых схожие метрики считаются клонами. Рассматриваемый метод позволяет отыскать клоны на уровне функций, но не справляется с поиском клонов меньших размеров~\cite{2018art}.

\nomenclature{LOC}{Lines of Code}
\nomenclature{CFG}{Control Flow Graph}

\subsection{Смешанные методы}

Помимо рассмотренных методов, существует такая группа, которая использует смешанный подход. Иными словами, используются несколько из рассмотренных выше структур для создания внутреннего представления программы. Одним из самых популярных гибридных подходов является получение и сериализация синтаксического дерева в последовательность токенов~\cite{hybrid}. Такое смешивание позволяет анализировать структурную информацию, получаемую из AST, используя эффективные строковые алгоритмы. 

\subsection{Сравнение методов поиска клонов}

В данном пункте были рассмотрены подходы, применяемые в задачах поиска программных клонов, приведены основные определения, связанные с предметной областью. В рамках обзора рассмотрены основные характеристики, преимущества и недостатки методов.

В табл.~\ref{compare} представлен сравнительный анализ подходов на основе следующих характеристик:
\begin{itemize}
\setlength\itemsep{0mm}
\item гранулярность - размер минимального клона
\item тип клонов, которые возможно обнаружить с помощью данного подхода
\item полнота обнаружения
\item точность обнаружения
\end{itemize}

\begin{table}[H]
\centering
\captionsetup{skip=5pt}
\caption{Сравнительный анализ подходов}
\label{compare}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
Представление    & Гран.		& Тип клонов & Скорость & Полнота	& Точность \\ \hline
Текст            & Свободная    & I          & Высокая  & Низкая  	& Высокая  \\ \hline
Токены           & Свободная    & I-II       & Средняя  & Высокая 	& Низкая   \\ \hline
Синт. деревья	 & Свободная    & I-III      & Средняя  & Низкая  	& Высокая  \\ \hline
Графы            & Свободная    & I-IV       & Низкая   & Средняя 	& Высокая  \\ \hline
Метрики          & Фикс.		& I-IV       & Средняя  & Средняя 	& Средняя  \\ \hline
\end{tabular}
\end{table}

Основываясь на приведенных требованиях, представленных в пункте~\ref{section:compare}, можно сделать вывод о невозможности использования методов с внутренним представлением в виде текста или токенов. А в связи с низкой полнотой обнаружения при использовании методов, основанных на анализе синтаксических деревьев, такие методы также отпадают.

\section{Итоги раздела}

В данном разделе были приведены основные определения и классификации, связанные с предметной областью. Был произведен анализ применяемых методов в задачах поиска клонов и существующих архитектур искусственных нейронных сетей.
